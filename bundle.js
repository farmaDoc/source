!function t(s,e,n){function i(o,u){if(!e[o]){if(!s[o]){var h="function"==typeof require&&require;if(!u&&h)return h(o,!0);if(r)return r(o,!0);var p=new Error("Cannot find module '"+o+"'");throw p.code="MODULE_NOT_FOUND",p}var a=e[o]={exports:{}};s[o][0].call(a.exports,(function(t){return i(s[o][1][t]||t)}),a,a.exports,t,s,e,n)}return e[o].exports}for(var r="function"==typeof require&&require,o=0;o<n.length;o++)i(n[o]);return i}({1:[function(t,s,e){const n=t("@nlpjs/neural");window.bot={...n}},{"@nlpjs/neural":3}],2:[function(t,s,e){const n=t("./lookup");s.exports=class{constructor(t,s){if(t){this.inputLookup=new n,this.outputLookup=new n;for(let s=0;s<t.length;s+=1)this.inputLookup.add(t[s]);for(let t=0;t<s.length;t+=1)this.outputLookup.add(s[t]);this.numInputs=this.inputLookup.items.length,this.numOutputs=this.outputLookup.items.length}}build(t){this.inputLookup=new n(t,"input"),this.outputLookup=new n(t,"output"),this.numInputs=this.inputLookup.items.length,this.numOutputs=this.outputLookup.items.length;const s=[];for(let e=0;e<t.length;e+=1){const{input:n,output:i}=t[e];s.push({input:this.inputLookup.prepare(n),output:this.outputLookup.prepare(i)})}return s}transformInput(t){return this.inputLookup.prepare(t)}}},{"./lookup":4}],3:[function(t,s,e){const n=t("./neural-network");s.exports={NeuralNetwork:n}},{"./neural-network":5}],4:[function(t,s,e){s.exports=class{constructor(t,s="input"){this.dict={},this.items=[],t&&this.buildFromData(t,s)}add(t){void 0===this.dict[t]&&(this.dict[t]=this.items.length,this.items.push(t))}buildFromData(t,s){for(let e=0;e<t.length;e+=1){const n=t[e][s],i=Object.keys(n);for(let t=0;t<i.length;t+=1)this.add(i[t])}}prepare(t){const s=Object.keys(t),e=[],n={};for(let i=0;i<s.length;i+=1){const r=s[i];void 0!==this.dict[r]&&(e.push(this.dict[r]),n[this.dict[r]]=t[r])}return{keys:e,data:n}}}},{}],5:[function(t,s,e){const n=t("./corpus-lookup"),i={iterations:2e4,errorThresh:5e-5,deltaErrorThresh:1e-6,learningRate:.6,momentum:.5,alpha:.07,log:!1};s.exports=class{constructor(t={}){this.settings=t,this.applySettings(this.settings,i),!0===this.settings.log?this.logFn=(t,s)=>console.log(`Epoch ${t.iterations} loss ${t.error} time ${s}ms`):"function"==typeof this.settings.log&&(this.logFn=this.settings.log)}applySettings(t={},s={}){return Object.keys(s).forEach((e=>{void 0===t[e]&&(t[e]=s[e])})),t}initialize(t,s){this.perceptronsByName={},this.perceptrons=[],this.outputs={},this.numPerceptrons=s.length;for(let e=0;e<s.length;e+=1){const n=s[e];this.outputs[n]=0;const i={name:n,id:e,weights:new Float32Array(t),changes:new Float32Array(t),bias:0};this.perceptrons.push(i),this.perceptronsByName[n]=i}}runInputPerceptron(t,s){const e=s.keys.reduce(((e,n)=>e+s.data[n]*t.weights[n]),t.bias);return e<=0?0:this.settings.alpha*e}runInput(t){for(let s=0;s<this.numPerceptrons;s+=1)this.outputs[this.perceptrons[s].name]=this.runInputPerceptron(this.perceptrons[s],t);return this.outputs}get isRunnable(){return!!this.numPerceptrons}run(t){return this.numPerceptrons?this.runInput(this.lookup.transformInput(t)):void 0}prepareCorpus(t){return this.lookup=new n,this.lookup.build(t)}verifyIsInitialized(){this.perceptrons||this.initialize(this.lookup.numInputs,this.lookup.outputLookup.items)}trainPerceptron(t,s){const{alpha:e,momentum:n}=this.settings,{changes:i,weights:r}=t;let o=0;for(let u=0;u<s.length;u+=1){const{input:h,output:p}=s[u],a=this.runInputPerceptron(t,h),l=(p.data[t.id]||0)-a;if(l){o+=l**2;const s=(a>0?1:e)*l*this.decayLearningRate;for(let t=0;t<h.keys.length;t+=1){const e=h.keys[t],o=s*h.data[e]+n*i[e];i[e]=o,r[e]+=o}t.bias+=s}}return o}train(t){if(!t||!t.length)return{};if(void 0!==t[t.length-1].input.nonefeature){const s={};for(let e=0;e<t.length-1;e+=1){const n=Object.keys(t[e].output);for(let t=0;t<n.length;t+=1)s[n[t]]||(s[n[t]]=1)}const e=t[t.length-1],n=Object.keys(s);for(let t=0;t<n.length;t+=1)e.output[n[t]]=1e-7}const s=this.prepareCorpus(t);this.status||(this.status={error:1/0,deltaError:1/0,iterations:0}),this.verifyIsInitialized();const e=this.settings.errorThresh,n=this.settings.deltaErrorThresh;for(;this.status.iterations<this.settings.iterations&&this.status.error>e&&this.status.deltaError>n;){const t=new Date;this.status.iterations+=1,this.decayLearningRate=this.settings.learningRate/(1+.001*this.status.iterations);const e=this.status.error;this.status.error=0;for(let t=0;t<this.numPerceptrons;t+=1)this.status.error+=this.trainPerceptron(this.perceptrons[t],s);this.status.error/=this.numPerceptrons*s.length,this.status.deltaError=Math.abs(this.status.error-e);const n=new Date;this.logFn&&this.logFn(this.status,n.getTime()-t.getTime())}return this.status}explain(t,s){const e=this.lookup.transformInput(t),n={},i=this.lookup.outputLookup.dict[s];if(void 0===i)return{};for(let t=0;t<e.keys.length;t+=1){const s=e.keys[t];n[this.lookup.inputLookup.items[s]]=this.perceptrons[i].weights[s]}return{weights:n,bias:this.perceptrons[i].bias}}toJSON(){const t={},s=Object.keys(this.settings);for(let e=0;e<s.length;e+=1){const n=s[e];this.settings[n]!==i[n]&&(t[n]=this.settings[n])}if(!this.lookup)return{settings:t};const e=this.lookup.inputLookup.items,n=this.lookup.outputLookup.items,r=[];for(let t=0;t<this.perceptrons.length;t+=1){const s=this.perceptrons[t],e=[...s.weights,s.bias];r.push(e)}return{settings:t,features:e,intents:n,perceptrons:r}}fromJSON(t){if(this.settings=this.applySettings({...i,...t.settings}),t.features){this.lookup=new n(t.features,t.intents),this.initialize(t.features.length,t.intents);for(let s=0;s<this.perceptrons.length;s+=1){const e=this.perceptrons[s],n=t.perceptrons[s];e.bias=n[n.length-1];for(let s=0;s<t.features.length;s+=1)e.weights[s]=n[s]}}}}},{"./corpus-lookup":2}]},{},[1]);
